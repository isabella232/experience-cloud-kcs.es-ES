---
title: "Consulta incremental recoge todos los registros en lugar de solo los nuevos"
description: Descripción
solution: Campaign
product: Campaign
applies-to: "Campaign Classic"
keywords: "KCS"
resolution: Resolution
internal-notes: "Ticket = TK197178"
bug: true
article-created-by: Tanay Sharma .
article-created-date: "9/26/2022 10:11:48 AM"
article-published-by: Tanay Sharma .
article-published-date: "9/26/2022 11:03:23 AM"
version-number: 3
article-number: KA-15190
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=e647789f-833d-ed11-9db1-002248086735"
source-git-commit: c07227262cb059b09254e8e1ec01542d4de2a881
workflow-type: tm+mt
source-wordcount: '353'
ht-degree: 0%

---

# La consulta incremental recoge todos los registros en lugar de solo los nuevos

## Descripción

<b>Entorno</b>
Campaign Classic


<b>Problema/Síntomas</b>
Las consultas incrementales no funcionan como se espera. En lugar de recoger solo registros nuevos desde su última ejecución, están recogiendo todos los registros cada vez como una actividad de consulta normal.


## Resolución


Este problema se corrige en la versión 20.1.1 de Adobe Campaign Classic (versión 9122 y posteriores).

<b>Soluciones que los clientes pueden utilizar:</b>

<b>Solución 1</b>: Detenga el flujo de trabajo de limpieza y ejecútelo de forma intermitente para limpiar la base de datos y el disco duro hasta que la corrección esté disponible. No se recomienda si no tiene una actualización planificada.

<b>Solución 2</b>: Supongamos que la actividad de consulta incremental se ve afectada. Para evitarlo, haga lo mismo que la consulta incremental creando un esquema persistente para guardar el contenido de la tabla del historial. Utilice una combinación de actividades de consulta y actualización de datos para imitar el comportamiento. Esto debe hacerse para todos los flujos de trabajo que requieren la consulta incremental.

<b>Solución 3</b>:  Supongamos que la actividad de consulta incremental se ve afectada. Para evitarlo, agregue un campo de auditoría `tsCreated/tsLastModified` al esquema en cuestión. La consulta incremental se convertirá entonces a una actividad de consulta normal con una cláusula where como `tscreated GetDate()&quot;.

<b>Solución 4</b>:

1. Crear una nueva secuencia `xtknewworkflowid` e inicialícelo en algo lejos de los intervalos de workflowId actuales.
2. Cambie el `xtkworkflow` esquema para usar esto `pkSequence`.
3. Pida al cliente que clone todos los flujos de trabajo afectados y que elimine los originales.
4. Una vez que el cliente esté listo para una actualización, elimine esta corrección volviendo a `xtknewId` para la creación del flujo de trabajo (para evitar sorpresas no deseadas).

<b>Causa</b>
El culpable es el flujo de trabajo de limpieza.

El flujo de trabajo de consulta incremental funciona de esta manera:

1. Mantiene una tabla de historial con resultados de iteraciones anteriores.
2. Recupera todas las filas de la consulta de destino.
3. Filtra todas las filas presentes en la tabla de historial
4. Agrega los resultados restantes a la tabla de historial para el siguiente filtro de iteración.


Por lo tanto, este nombre de tabla de trabajo del historial es de la siguiente notación:
`wkfhistoworkflowid` `activityName_`

Ahora, para los ID de flujo de trabajo 0 (para clientes donde la variable `xtknewid` permite secuencias negativas), vemos que en realidad es:

`wkfhisto(uint)workflowid``activityName_`

`Although this is okay for workflow execution.`

`So, for example, the incremental activity incremental1 of workflow ID=-1 will create a table wkfhisto4294967295_incremental1`.`

`The thing which is missed is the CleanUp workflow.`

`Here, we have a code that tries to delete worktables of deleted workflows.`

`A dedicated code here lists all the wkfhisto tables, extracts the workflowId from their names (from the above convention), and deletes them all except the ones whose worklowIDs are found in the xtkworkflow table.`

`However, it misses the uint part.`

`So, it tries to look up a workflow with ID 4294967295 instead of casting this back to int. Since this workflow is not found, this table is deleted. Next time, when this workflow runs, the incremental query activity does not find an existing history table and creates it thinking of this as the first run ever.`
